From aff358eb5cf6721a4f05bc02e40cbc9acc9841c4 Mon Sep 17 00:00:00 2001
From: Tianshun Gao <tgao13@illinois.edu>
Date: Wed, 2 Apr 2025 05:10:05 -0700
Subject: [PATCH 141/150] (feat): add follow camera mode and control for car
 movement

---
 .../sr_viz/threeD/components/Car.js           | 202 +++++++-----------
 .../threeD/components/RoadVehicleViz.vue      |  69 ++++--
 .../sr_viz/threeD/components/TrafficLight.js  |   8 +-
 3 files changed, 134 insertions(+), 145 deletions(-)

diff --git a/GEMstack/onboard/visualization/sr_viz/threeD/components/Car.js b/GEMstack/onboard/visualization/sr_viz/threeD/components/Car.js
index 3cd9b4cd..40958abe 100644
--- a/GEMstack/onboard/visualization/sr_viz/threeD/components/Car.js
+++ b/GEMstack/onboard/visualization/sr_viz/threeD/components/Car.js
@@ -1,119 +1,24 @@
-// import * as THREE from 'three';
-
-// const TIRE_RADIUS = 0.4;
-// const TIRE_WIDTH = 0.5;
-// const BODY_X = 2;
-// const BODY_Y = 1;
-// const BODY_Z = 4;
-// const UPPER_BODY_COLOR = 0xffffff;
-// const UPPER_BODY_X = 1.6;
-// const UPPER_BODY_Y = 0.8;
-// const UPPER_BODY_Z = 2.2;
-// const UPPER_BODY_Z_OFFSET = -0.2;
-// const WINDOWS_COLOR = 0xaaaaaa;
-// const WINDOWS_THICKNESS = 0.05;
-// const SIDE_WINDOWS_X = WINDOWS_THICKNESS;
-// const WINDOWS_Y = 0.6;
-// const FRONT_SIDE_WINDOWS_Z = UPPER_BODY_Z / 11 * 5;
-// const BACK_SIDE_WINDOWS_Z = UPPER_BODY_Z / 11 * 3;
-// const FRONT_BACK_WINDOWS_X = 1.3;
-// const FRONT_BACK_WINDOWS_Z = WINDOWS_THICKNESS;
-// export const CAR_HEIGHT = TIRE_RADIUS + BODY_Y + UPPER_BODY_Y;
-
-// export default class Car {
-//   constructor(color = 0xff0000, position = { x: 0, z: 0 }, direction = 0) {
-//     this.group = new THREE.Group();
-//     this.color = color;
-//     this.createBody(color);
-//     this.createWindows();
-//     this.createWheels();
-//     // this.createDoors();
-//     this.group.position.set(position.x, 0, position.z);
-//     this.group.rotation.y = direction;
-//   }
-
-//   createBody(color) {
-//     const bodyGeometry = new THREE.BoxGeometry(BODY_X, BODY_Y, BODY_Z);
-//     const bodyMaterial = new THREE.MeshStandardMaterial({ color });
-//     this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
-//     this.body.position.y = TIRE_RADIUS + (BODY_Y / 2);
-//     const upperBodyGeometry = new THREE.BoxGeometry(UPPER_BODY_X, UPPER_BODY_Y, UPPER_BODY_Z);
-//     const upperBodyMaterial = new THREE.MeshStandardMaterial({ color: UPPER_BODY_COLOR });
-//     this.upperbody = new THREE.Mesh(upperBodyGeometry, upperBodyMaterial);
-//     this.upperbody.position.set(0, TIRE_RADIUS + BODY_Y + UPPER_BODY_Y / 2, UPPER_BODY_Z_OFFSET);
-//     this.group.add(this.body);
-//     this.group.add(this.upperbody);
-//   }
-
-//   createWindows() {
-//     const FrontSideWindowGeometry = new THREE.BoxGeometry(SIDE_WINDOWS_X, WINDOWS_Y, FRONT_SIDE_WINDOWS_Z);
-//     const windowMaterial = new THREE.MeshStandardMaterial({ color: WINDOWS_COLOR, transparent: true, opacity: 0.5 });
-//     this.frontDriverSideWindows = new THREE.Mesh(FrontSideWindowGeometry, windowMaterial);
-//     this.frontDriverSideWindows.position.set((UPPER_BODY_X + SIDE_WINDOWS_X) / 2, TIRE_RADIUS + BODY_Y + UPPER_BODY_Y / 2, UPPER_BODY_Z_OFFSET + (UPPER_BODY_Z / 2 - UPPER_BODY_Z / 11 - FRONT_SIDE_WINDOWS_Z / 2));
-//     this.group.add(this.frontDriverSideWindows);
-//     this.frontPassengerSideWindows = new THREE.Mesh(FrontSideWindowGeometry, windowMaterial);
-//     this.frontPassengerSideWindows.position.set(-(UPPER_BODY_X + SIDE_WINDOWS_X) / 2, TIRE_RADIUS + BODY_Y + UPPER_BODY_Y / 2, UPPER_BODY_Z_OFFSET + (UPPER_BODY_Z / 2 - UPPER_BODY_Z / 11 - FRONT_SIDE_WINDOWS_Z / 2));
-//     this.group.add(this.frontPassengerSideWindows);
-//     const BackSideWindowGeometry = new THREE.BoxGeometry(SIDE_WINDOWS_X, WINDOWS_Y, BACK_SIDE_WINDOWS_Z);
-//     this.backDriverSideWindows = new THREE.Mesh(BackSideWindowGeometry, windowMaterial);
-//     this.backDriverSideWindows.position.set((UPPER_BODY_X + SIDE_WINDOWS_X) / 2, TIRE_RADIUS + BODY_Y + UPPER_BODY_Y / 2, UPPER_BODY_Z_OFFSET - (UPPER_BODY_Z / 2 - UPPER_BODY_Z / 11 - BACK_SIDE_WINDOWS_Z / 2));
-//     this.group.add(this.backDriverSideWindows);
-//     this.backPassengerSideWindows = new THREE.Mesh(BackSideWindowGeometry, windowMaterial);
-//     this.backPassengerSideWindows.position.set(-(UPPER_BODY_X + SIDE_WINDOWS_X) / 2, TIRE_RADIUS + BODY_Y + UPPER_BODY_Y / 2, UPPER_BODY_Z_OFFSET - (UPPER_BODY_Z / 2 - UPPER_BODY_Z / 11 - BACK_SIDE_WINDOWS_Z / 2));
-//     this.group.add(this.backPassengerSideWindows);
-//     const FrontWindowGeometry = new THREE.BoxGeometry(FRONT_BACK_WINDOWS_X, WINDOWS_Y, FRONT_BACK_WINDOWS_Z);
-//     this.frontWindow = new THREE.Mesh(FrontWindowGeometry, windowMaterial);
-//     this.frontWindow.position.set(0, TIRE_RADIUS + BODY_Y + UPPER_BODY_Y / 2, UPPER_BODY_Z_OFFSET + (UPPER_BODY_Z + FRONT_BACK_WINDOWS_Z) / 2);
-//     this.group.add(this.frontWindow);
-//     const BackWindowGeometry = new THREE.BoxGeometry(FRONT_BACK_WINDOWS_X, WINDOWS_Y, FRONT_BACK_WINDOWS_Z);
-//     this.backWindow = new THREE.Mesh(BackWindowGeometry, windowMaterial);
-//     this.backWindow.position.set(0, TIRE_RADIUS + BODY_Y + UPPER_BODY_Y / 2, UPPER_BODY_Z_OFFSET - (UPPER_BODY_Z + FRONT_BACK_WINDOWS_Z) / 2);
-//     this.group.add(this.backWindow);
-//   }
-
-//   createWheels() {
-//     const wheelGeometry = new THREE.CylinderGeometry(TIRE_RADIUS, TIRE_RADIUS, TIRE_WIDTH, 16);
-//     const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
-
-//     const createWheel = (x, z) => {
-//       const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
-//       wheel.rotation.z = Math.PI / 2;
-//       wheel.position.set(x, TIRE_RADIUS, z);
-//       this.group.add(wheel);
-//     };
-//     const wheelOffset_X = (BODY_X - TIRE_WIDTH / 2) / 2;
-//     const wheelOffset_Z = (BODY_Z - 3 * TIRE_WIDTH) / 2;
-//     createWheel(wheelOffset_X, wheelOffset_Z);
-//     createWheel(wheelOffset_X, -wheelOffset_Z);
-//     createWheel(-wheelOffset_X, wheelOffset_Z);
-//     createWheel(-wheelOffset_X, -wheelOffset_Z);
-//   }
-
-//   createDoors() {
-//     const doorGeometry = new THREE.BoxGeometry(0.02, 0.8, 1.5);
-//     const doorMaterial = new THREE.MeshStandardMaterial({ color: this.color });
-
-//     const leftDoor = new THREE.Mesh(doorGeometry, doorMaterial);
-//     leftDoor.position.set(-1, 0.5, 0);
-//     this.group.add(leftDoor);
-
-//     const rightDoor = new THREE.Mesh(doorGeometry, doorMaterial);
-//     rightDoor.position.set(1, 0.5, 0);
-//     this.group.add(rightDoor);
-//   }
-// }
 import * as THREE from "three";
 import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
+const CAR_X = 19651.6005859375;
+const CAR_Y = 14238.344896316528;
+const CAR_Z = 47565.92169100046;
 const SCALE_RATE = 0.0002;
+export const CAR_WIDTH = CAR_X * SCALE_RATE;
+export const CAR_HEIGHT = CAR_Y * SCALE_RATE;
+export const CAR_LENGTH = CAR_Z * SCALE_RATE;
 
-export default class Car {
+export class Car {
     constructor(modelPath, position = { x: 0, y: 0, z: 0 }, onLoadCallback) {
         this.position = new THREE.Vector3(position.x, position.y, position.z);
+        this.heading = Math.PI / 2;
         this.velocity = 0;
-        this.acceleration = 0.002;
-        this.maxSpeed = 0.2;
+        this.wheelBase = CAR_LENGTH * 5 / 8; // Distance between front and rear axles
+        this.maxSpeed = 20;
+        this.acceleration = 0.5;
         this.friction = 0.98;
-        this.rotationSpeed = 0.003;
+        this.steerAngle = 0;
+        this.maxSteerAngle = Math.PI / 6;
 
         const loader = new GLTFLoader();
         loader.load(
@@ -130,23 +35,78 @@ export default class Car {
         );
     }
 
-    update(keys) {
+    update(keys, dt) {
         if (!this.group) return;
-    
+
         if (keys.forward) this.velocity = Math.min(this.velocity + this.acceleration, this.maxSpeed);
         if (keys.backward) this.velocity = Math.max(this.velocity - this.acceleration, -this.maxSpeed);
         this.velocity *= this.friction;
-        
-        if (Math.abs(this.velocity) > 0.001) { 
-            if (keys.left) this.group.rotation.y += this.rotationSpeed;
-            if (keys.right) this.group.rotation.y -= this.rotationSpeed;
-        }
-        if (Math.abs(this.velocity) > 0.001) { 
-            const direction = new THREE.Vector3(0, 0, 1);
-            direction.applyQuaternion(this.group.quaternion);
-            direction.multiplyScalar(this.velocity);
-            this.group.position.add(direction);
-        }
+
+        if (keys.left) this.steerAngle = Math.max(this.steerAngle - 0.02, -this.maxSteerAngle);
+        if (keys.right) this.steerAngle = Math.min(this.steerAngle + 0.02, this.maxSteerAngle);
+        if (!keys.left && !keys.right) this.steerAngle *= 0.9;
+
+        const frontWheel = this.position.clone().add(new THREE.Vector3(
+            Math.cos(this.heading) * (this.wheelBase / 2) + Math.sin(this.heading) * (CAR_WIDTH / 2),
+            0,
+            Math.sin(this.heading) * (this.wheelBase / 2) - Math.cos(this.heading) * (CAR_WIDTH / 2)
+        ));
+        const backWheel = this.position.clone().add(new THREE.Vector3(
+            -Math.cos(this.heading) * (this.wheelBase / 2) + Math.sin(this.heading) * (CAR_WIDTH / 2),
+            0,
+            -Math.sin(this.heading) * (this.wheelBase / 2) - Math.cos(this.heading) * (CAR_WIDTH / 2)
+        ));
+
+        backWheel.add(new THREE.Vector3(
+            Math.cos(this.heading) * this.velocity * dt,
+            0,
+            Math.sin(this.heading) * this.velocity * dt
+        ));
+        frontWheel.add(new THREE.Vector3(
+            Math.cos(this.heading + this.steerAngle) * this.velocity * dt,
+            0,
+            Math.sin(this.heading + this.steerAngle) * this.velocity * dt
+        ));
+
+        this.position = frontWheel.clone().add(backWheel).multiplyScalar(0.5).add(new THREE.Vector3(
+            -Math.sin(this.heading) * (CAR_WIDTH / 2),
+            0,
+            Math.cos(this.heading) * (CAR_WIDTH / 2)
+        ));
+        this.heading = Math.atan2(frontWheel.z - backWheel.z, frontWheel.x - backWheel.x);
+
+        this.group.position.copy(this.position);
+        this.group.rotation.y = -this.heading + Math.PI / 2;
+    }
+
+
+    dispose() {
+        if (!this.group) return;
+
+        this.group.traverse((child) => {
+            if (child.isMesh) {
+                child.geometry.dispose();
+
+                if (child.material) {
+                    if (Array.isArray(child.material)) {
+                        child.material.forEach((material) => {
+                            material.map?.dispose();
+                            material.normalMap?.dispose();
+                            material.roughnessMap?.dispose();
+                            material.dispose();
+                        });
+                    } else {
+                        child.material.map?.dispose();
+                        child.material.normalMap?.dispose();
+                        child.material.roughnessMap?.dispose();
+                        child.material.dispose();
+                    }
+                }
+            }
+        });
+
+        this.group.removeFromParent();
+        this.group = null;
     }
 }
 
diff --git a/GEMstack/onboard/visualization/sr_viz/threeD/components/RoadVehicleViz.vue b/GEMstack/onboard/visualization/sr_viz/threeD/components/RoadVehicleViz.vue
index ed17799f..54ce1099 100644
--- a/GEMstack/onboard/visualization/sr_viz/threeD/components/RoadVehicleViz.vue
+++ b/GEMstack/onboard/visualization/sr_viz/threeD/components/RoadVehicleViz.vue
@@ -11,8 +11,7 @@
 <script setup>
 import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
-import Car from "@/components/Car.js";
+import { Car, CAR_WIDTH, CAR_HEIGHT, CAR_LENGTH } from "@/components/Car.js";
 import TrafficLight from "@/components/TrafficLight.js";
 import {
     CAR_MODEL_PATH,
@@ -21,37 +20,45 @@ import {
 
 const container = ref(null);
 const camera = ref(null);
+const cameraMode = ref("free");
 let scene, renderer, controls;
 
 let car, trafficLight1, roadGeometry, roadMaterial;
-let roadTileGroup = [];
-const NUM_TILES = 5;
-const TILE_LENGTH = 50;
-const ROAD_SIZE = 20;
-const GRID_SIZE = 3;
+let lastTime = performance.now();
 
 const keys = { forward: false, backward: false, left: false, right: false };
 
 onMounted(() => {
     window.addEventListener("keydown", handleKeyDown);
     window.addEventListener("keyup", handleKeyUp);
+    window.addEventListener("keypress", handleKeyPress);
 
     initScene();
-    car = new Car(CAR_MODEL_PATH, { x: 0, y: 0, z: 0 }, (loadedCar) => {
-        scene.add(loadedCar.group);
-    });
+    car = new Car(CAR_MODEL_PATH, { x: 0, y: 0, z: 0 }, loadCallBack);
 
     trafficLight1 = new TrafficLight(
         TRAFFIC_LIGHT_MODEL_PATH,
         { x: 0, y: 0, z: 5 },
-        (loadedLight) => {
-            scene.add(loadedLight.group);
-        }
+        loadCallBack
     );
 
     animate();
 });
 
+function loadCallBack(object) {
+    scene.add(object.group);
+}
+
+function handleKeyPress(event) {
+    if (event.key === "c" || event.key === "C") {
+        if (cameraMode.value === "free") {
+            cameraMode.value = "follow";
+        } else {
+            cameraMode.value = "free";
+        }
+    }
+}
+
 function handleKeyDown(event) {
     switch (event.code) {
         case "ArrowUp":
@@ -139,30 +146,52 @@ function loadRoad() {
         map: diffuseTexture,
         normalMap: normalTexture,
         roughnessMap: roughnessTexture,
-        roughness: 0.7,
+        roughness: 1,
     });
     roadMaterial.map.wrapS = THREE.RepeatWrapping;
     roadMaterial.map.wrapT = THREE.RepeatWrapping;
-    roadMaterial.map.repeat.set(2, 2);
+    roadMaterial.map.repeat.set(100, 100);
 
-    roadGeometry = new THREE.PlaneGeometry(50, 50);
+    roadGeometry = new THREE.PlaneGeometry(1000, 1000);
     const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
     roadMesh.rotation.x = -Math.PI / 2;
 
     roadMesh.position.set(0, 0, 0);
 
     scene.add(roadMesh);
-    roadTileGroup.push(roadMesh);
 }
 
-function updateRoadTiles() {}
+function updateCamera() {
+    if (!car || !car.group) return;
+    if (cameraMode.value === "free") return;
+
+    const carPosition = car.group.position;
+    const carDirection = new THREE.Vector3();
+    car.group.getWorldDirection(carDirection);
+
+    camera.value.position.set(
+        carPosition.x - carDirection.x * 2 * CAR_LENGTH,
+        carPosition.y + 3 * CAR_HEIGHT,
+        carPosition.z - carDirection.z * 2 * CAR_LENGTH
+    );
+
+    controls.target.set(
+        carPosition.x + carDirection.x * 10 * CAR_LENGTH,
+        carPosition.y + CAR_HEIGHT / 2,
+        carPosition.z + carDirection.z * 10 * CAR_LENGTH
+    );
+}
 
 function animate() {
     requestAnimationFrame(animate);
+    const currentTime = performance.now();
+    const dt = (currentTime - lastTime) / 1000;
+    lastTime = currentTime;
+
     if (car) {
-        car.update(keys);
+        car.update(keys, dt);
     }
-    // updateRoadTiles();
+    updateCamera();
     controls.update();
     renderer.render(scene, camera.value);
 }
diff --git a/GEMstack/onboard/visualization/sr_viz/threeD/components/TrafficLight.js b/GEMstack/onboard/visualization/sr_viz/threeD/components/TrafficLight.js
index 9d72ceb1..e018417a 100644
--- a/GEMstack/onboard/visualization/sr_viz/threeD/components/TrafficLight.js
+++ b/GEMstack/onboard/visualization/sr_viz/threeD/components/TrafficLight.js
@@ -77,9 +77,9 @@ export default class TrafficLight {
         const loader = new GLTFLoader();
         loader.load(
             modelPath,
-            (fbx) => {
-                this.group = fbx.scene;
-                
+            (gltf) => {
+                this.group = gltf.scene;
+
                 this.group.position.set(this.position.x, this.position.y, this.position.z);
                 this.group.scale.set(SCALE_RATE, SCALE_RATE, SCALE_RATE);
 
@@ -90,6 +90,6 @@ export default class TrafficLight {
         );
     }
     // update() {
-        
+
     // }
 }
\ No newline at end of file
-- 
2.38.1

