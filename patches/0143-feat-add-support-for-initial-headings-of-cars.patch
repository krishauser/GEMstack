From d5258cb8c6c5ecca2ce4b66022ad6e79b827de88 Mon Sep 17 00:00:00 2001
From: Tianshun Gao <tgao13@illinois.edu>
Date: Wed, 2 Apr 2025 07:09:17 -0700
Subject: [PATCH 143/150] (feat): add support for initial headings of cars

---
 .../sr_viz/threeD/components/Car.js           | 35 +++++++-------
 .../sr_viz/threeD/components/Human.js         |  2 -
 .../threeD/components/RoadVehicleViz.vue      | 47 +++++++++++++++++--
 3 files changed, 60 insertions(+), 24 deletions(-)

diff --git a/GEMstack/onboard/visualization/sr_viz/threeD/components/Car.js b/GEMstack/onboard/visualization/sr_viz/threeD/components/Car.js
index 40958abe..fdf7550b 100644
--- a/GEMstack/onboard/visualization/sr_viz/threeD/components/Car.js
+++ b/GEMstack/onboard/visualization/sr_viz/threeD/components/Car.js
@@ -9,11 +9,11 @@ export const CAR_HEIGHT = CAR_Y * SCALE_RATE;
 export const CAR_LENGTH = CAR_Z * SCALE_RATE;
 
 export class Car {
-    constructor(modelPath, position = { x: 0, y: 0, z: 0 }, onLoadCallback) {
+    constructor(modelPath, position = { x: 0, y: 0, z: 0 }, heading = Math.PI / 2, onLoadCallback) {
         this.position = new THREE.Vector3(position.x, position.y, position.z);
-        this.heading = Math.PI / 2;
+        this.heading = heading;
         this.velocity = 0;
-        this.wheelBase = CAR_LENGTH * 5 / 8; // Distance between front and rear axles
+        this.wheelBase = CAR_LENGTH * 5 / 8;
         this.maxSpeed = 20;
         this.acceleration = 0.5;
         this.friction = 0.98;
@@ -27,6 +27,7 @@ export class Car {
                 this.group = gltf.scene;
                 this.group.position.set(this.position.x, this.position.y, this.position.z);
                 this.group.scale.set(SCALE_RATE, SCALE_RATE, SCALE_RATE);
+                this.group.rotation.y = this.heading;
 
                 if (onLoadCallback) onLoadCallback(this);
             },
@@ -42,41 +43,41 @@ export class Car {
         if (keys.backward) this.velocity = Math.max(this.velocity - this.acceleration, -this.maxSpeed);
         this.velocity *= this.friction;
 
-        if (keys.left) this.steerAngle = Math.max(this.steerAngle - 0.02, -this.maxSteerAngle);
-        if (keys.right) this.steerAngle = Math.min(this.steerAngle + 0.02, this.maxSteerAngle);
+        if (keys.right) this.steerAngle = Math.max(this.steerAngle - 0.02, -this.maxSteerAngle);
+        if (keys.left) this.steerAngle = Math.min(this.steerAngle + 0.02, this.maxSteerAngle);
         if (!keys.left && !keys.right) this.steerAngle *= 0.9;
 
         const frontWheel = this.position.clone().add(new THREE.Vector3(
-            Math.cos(this.heading) * (this.wheelBase / 2) + Math.sin(this.heading) * (CAR_WIDTH / 2),
+            Math.sin(this.heading) * (this.wheelBase / 2) - Math.cos(this.heading) * (CAR_WIDTH / 2),
             0,
-            Math.sin(this.heading) * (this.wheelBase / 2) - Math.cos(this.heading) * (CAR_WIDTH / 2)
+            Math.cos(this.heading) * (this.wheelBase / 2) + Math.sin(this.heading) * (CAR_WIDTH / 2)
         ));
         const backWheel = this.position.clone().add(new THREE.Vector3(
-            -Math.cos(this.heading) * (this.wheelBase / 2) + Math.sin(this.heading) * (CAR_WIDTH / 2),
+            -Math.sin(this.heading) * (this.wheelBase / 2) - Math.cos(this.heading) * (CAR_WIDTH / 2),
             0,
-            -Math.sin(this.heading) * (this.wheelBase / 2) - Math.cos(this.heading) * (CAR_WIDTH / 2)
+            -Math.cos(this.heading) * (this.wheelBase / 2) + Math.sin(this.heading) * (CAR_WIDTH / 2)
         ));
 
         backWheel.add(new THREE.Vector3(
-            Math.cos(this.heading) * this.velocity * dt,
+            Math.sin(this.heading) * this.velocity * dt,
             0,
-            Math.sin(this.heading) * this.velocity * dt
+            Math.cos(this.heading) * this.velocity * dt
         ));
         frontWheel.add(new THREE.Vector3(
-            Math.cos(this.heading + this.steerAngle) * this.velocity * dt,
+            Math.sin(this.heading + this.steerAngle) * this.velocity * dt,
             0,
-            Math.sin(this.heading + this.steerAngle) * this.velocity * dt
+            Math.cos(this.heading + this.steerAngle) * this.velocity * dt
         ));
 
         this.position = frontWheel.clone().add(backWheel).multiplyScalar(0.5).add(new THREE.Vector3(
-            -Math.sin(this.heading) * (CAR_WIDTH / 2),
+            Math.cos(this.heading) * (CAR_WIDTH / 2),
             0,
-            Math.cos(this.heading) * (CAR_WIDTH / 2)
+            -Math.sin(this.heading) * (CAR_WIDTH / 2)
         ));
-        this.heading = Math.atan2(frontWheel.z - backWheel.z, frontWheel.x - backWheel.x);
+        this.heading = Math.atan2(frontWheel.x - backWheel.x, frontWheel.z - backWheel.z);
 
         this.group.position.copy(this.position);
-        this.group.rotation.y = -this.heading + Math.PI / 2;
+        this.group.rotation.y = this.heading;
     }
 
 
diff --git a/GEMstack/onboard/visualization/sr_viz/threeD/components/Human.js b/GEMstack/onboard/visualization/sr_viz/threeD/components/Human.js
index be4455cd..85317f7c 100644
--- a/GEMstack/onboard/visualization/sr_viz/threeD/components/Human.js
+++ b/GEMstack/onboard/visualization/sr_viz/threeD/components/Human.js
@@ -38,7 +38,6 @@ export default class Human {
         this.group.add(this.leftShoulderPivot);
 
         this.leftArm = new THREE.Mesh(armGeometry, armMaterial);
-        // this.leftArm.position.set(0, -HUMAN_ARM_LENGTH / 2, 0);
         this.leftShoulderPivot.add(this.leftArm);
 
         this.rightShoulderPivot = new THREE.Group();
@@ -50,7 +49,6 @@ export default class Human {
         this.group.add(this.rightShoulderPivot);
 
         this.rightArm = new THREE.Mesh(armGeometry, armMaterial);
-        // this.rightArm.position.set(0, -HUMAN_ARM_LENGTH / 2, 0);
         this.rightShoulderPivot.add(this.rightArm);
 
         const legGeometry = new THREE.CylinderGeometry(HUMAN_LEG_LENGTH / 6, HUMAN_LEG_LENGTH / 6, HUMAN_LEG_LENGTH);
diff --git a/GEMstack/onboard/visualization/sr_viz/threeD/components/RoadVehicleViz.vue b/GEMstack/onboard/visualization/sr_viz/threeD/components/RoadVehicleViz.vue
index 805f9a75..51aa12eb 100644
--- a/GEMstack/onboard/visualization/sr_viz/threeD/components/RoadVehicleViz.vue
+++ b/GEMstack/onboard/visualization/sr_viz/threeD/components/RoadVehicleViz.vue
@@ -39,13 +39,14 @@ onMounted(() => {
     window.addEventListener("keypress", handleKeyPress);
 
     initScene();
-    car = createCar(0, 0, 0);
+    car = createCar(0, 0, 0, Math.PI / 2);
     for (let i = 0; i < 4; i++) {
         const offset = (i + 1) * 10;
         createCar(
-            (i % 2 === 0 ? -1 : 1) * (Math.random() * 5 + offset),
+            offset,
             0,
-            offset
+            (i % 2 === 0 ? -1 : 1) * (Math.random() * 5),
+            Math.PI / 2
         );
     }
     createTrafficLight(0, 0, 5);
@@ -54,8 +55,8 @@ onMounted(() => {
     animate();
 });
 
-function createCar(x, y, z) {
-    const newCar = new Car(CAR_MODEL_PATH, { x: x, y: y, z: z }, loadCallBack);
+function createCar(x, y, z, heading) {
+    const newCar = new Car(CAR_MODEL_PATH, { x: x, y: y, z: z }, heading, loadCallBack);
     cars.push(newCar);
     return newCar;
 }
@@ -175,6 +176,7 @@ function initScene() {
 
     window.addEventListener("resize", onWindowResize, false);
 }
+
 function loadRoad() {
     const textureLoader = new THREE.TextureLoader();
 
@@ -205,6 +207,41 @@ function loadRoad() {
     roadMesh.position.set(0, 0, 0);
 
     scene.add(roadMesh);
+    
+    createRoadLines();
+}
+
+function createRoadLines() {
+    const lineMaterialSolid = new THREE.LineBasicMaterial({ color: 0xffff00 });
+    const lineMaterialDashed = new THREE.LineDashedMaterial({
+        color: 0xffffff,
+        dashSize: 5,
+        gapSize: 5,
+    });
+
+    const roadWidth = 20;
+    
+    const centerLineGeometry = new THREE.BufferGeometry().setFromPoints([
+        new THREE.Vector3(-500, 0.1, 0),
+        new THREE.Vector3(500, 0.1, 0),
+    ]);
+    const centerLine = new THREE.Line(centerLineGeometry, lineMaterialDashed);
+    centerLine.computeLineDistances();
+    scene.add(centerLine);
+
+    const leftLineGeometry = new THREE.BufferGeometry().setFromPoints([
+        new THREE.Vector3(-500, 0.1, roadWidth / 2),
+        new THREE.Vector3(500, 0.1, roadWidth / 2),
+    ]);
+    const leftLine = new THREE.Line(leftLineGeometry, lineMaterialSolid);
+    scene.add(leftLine);
+
+    const rightLineGeometry = new THREE.BufferGeometry().setFromPoints([
+        new THREE.Vector3(-500, 0.1, -roadWidth / 2),
+        new THREE.Vector3(500, 0.1, -roadWidth / 2),
+    ]);
+    const rightLine = new THREE.Line(rightLineGeometry, lineMaterialSolid);
+    scene.add(rightLine);
 }
 
 function updateCamera() {
-- 
2.38.1

