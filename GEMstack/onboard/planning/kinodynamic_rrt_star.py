import math
import random
import time
import numpy as np
import matplotlib.pyplot as plt
import scipy.spatial
from matplotlib import animation
# from utils import normalize_angle # Assuming provided
from .collision import fast_collision_check # Assuming provided
#from collision import fast_collision_check # Assuming provided
# Placeholder for normalize_angle if not imported
def normalize_angle(angle):
    while angle > math.pi: angle -= 2.0 * math.pi
    while angle < -math.pi: angle += 2.0 * math.pi
    return angle

class RRTNode:
    def __init__(self, x, y, theta, v=0.0, phi=0.0, cost=0.0, parent=None):
        self.x, self.y, self.theta = x, y, theta
        self.v, self.phi = v, phi
        self.cost = cost
        self.parent = parent
        self.path_from_parent = []

    def get_state(self): return (self.x, self.y, self.theta, self.v, self.phi)
    def get_position(self): return (self.x, self.y)

class OptimizedKinodynamicRRT:
    def __init__(self, occupancy_grid, collision_lookup,
                 start_pose, goal_pose,
                 max_iter=100000, # Increased iterations
                 step_size_local_viz=1000000.0, # For _sample_position_randomly's local step (visualization driving)
                 goal_sample_rate=0.5): # Adjusted goal_sample_rate
        
        self.grid = occupancy_grid
        self.collision_lookup = collision_lookup
        self.start_node = RRTNode(*start_pose, cost=0.0)
        self.true_goal_node_spec = RRTNode(*goal_pose)
        self.goal_node_for_tree = RRTNode(
            goal_pose[0], goal_pose[1],
            self._inverse_angle(goal_pose[2]), cost=0.0)

        self.max_iter = max_iter
        self.local_viz_step_size = step_size_local_viz # Renamed from self.step_size for clarity
        self.vehicle_length = 45.0
        self.dt = 0.1
        self.goal_sample_rate = goal_sample_rate

        self.nodes_start_tree = [self.start_node]
        self.nodes_goal_tree = [self.goal_node_for_tree]
        self.kdtree_start, self.kdtree_goal = None, None
        self.kdtree_rebuild_freq = 50

        self.path_found = False
        self.connection_details = None
        # Tuned thresholds for difficult maps
        self.goal_position_threshold = 500.0
        self.goal_angle_threshold = math.radians(60.0)
        self.max_steering_angle = math.pi/4
        self.max_velocity = 10.0
        self.min_velocity = 1.0

        self.grid_dims = self.collision_lookup["collision_mask"].shape
        self.time_budget = 20.0 # Increased time budget

        self.primitives = self._initialize_motion_primitives()

        self.steering_gain = 0.7
        self.smoothness_weight = 0.1
        self.goal_heading_weight = 250.0 # Kept very high

        # Visualization parameters from user's original code
        self.sample_wave_idx = 0
        diag = math.hypot(*self.grid_dims)
        self.max_wave_rings = 3
        
        self.nominal_connect_attempt_distance = 15.0
        self.connect_max_dist_factor = 1.5

        self.num_arcs = 3
        self.sample_arc_idx = 0
        self.min_radius = 30.0
        self.max_radius = 300.0

        self.last_start_node = self.start_node
        self.last_goal_node = self.goal_node_for_tree
        self.half_cone = math.pi/6

        self.recorded_samples = [] # Will store (x,y) of global samples for _extend_tree
        self.recorded_samples_local_viz = [] # For samples from _sample_position_randomly
        self.recorded_centers = []

    def _inverse_angle(self, theta):
        angle = normalize_angle(theta)
        if angle < 0:
            return angle + math.pi
        return angle-math.pi

    def _initialize_motion_primitives(self):
        primitives = []
        vs = [0.5*self.max_velocity, 0.8*self.max_velocity, self.max_velocity]
        sr = 0.9*self.max_steering_angle
        phis = np.array([0.0, 0.25*sr, -0.25*sr, 0.6*sr, -0.6*sr, sr, -sr])
        for v_val in vs:
            for phi_val in phis:
                steps = 15
                if abs(phi_val) > 0.5 * sr: steps = 20
                elif phi_val == 0.0: steps = 20 if v_val == self.max_velocity else 15
                prim = self._generate_primitive(v_val, phi_val, steps=steps)
                if prim: primitives.append(prim)
        # Ensure at least one straight primitive if not generated by linspace variations
        if not any(p[0][4] == 0.0 for p in primitives if p[0][3] == self.max_velocity and len(p)>15 ): # check if long straight exists
             primitives.append(self._generate_primitive(self.max_velocity, 0.0, steps=20))
        print(f"Initialized {len(primitives)} motion primitives.")
        return primitives

    def _generate_primitive(self, velocity, steering_angle, steps=15):
        path = [(0,0,0,velocity,steering_angle)]
        x,y,theta_val = 0.0,0.0,0.0
        for _ in range(steps):
            x += velocity * math.cos(theta_val) * self.dt
            y += velocity * math.sin(theta_val) * self.dt
            theta_val = normalize_angle(theta_val + (velocity * math.tan(steering_angle) / self.vehicle_length) * self.dt)
            path.append((x, y, theta_val, velocity, steering_angle))
        return path

    def _build_kdtree(self, tree_type='start'):
        nodes = self.nodes_start_tree if tree_type == 'start' else self.nodes_goal_tree
        if not nodes: return
        points = np.array([(n.x, n.y) for n in nodes])
        if points.ndim == 1: points = points.reshape(1, -1)
        if not points.size: return
        kdtree = scipy.spatial.cKDTree(points)
        if tree_type == 'start': self.kdtree_start = kdtree
        else: self.kdtree_goal = kdtree

    def _get_nearest_node(self, pos_xy, tree_type='start'):
        nodes_list = self.nodes_start_tree if tree_type == 'start' else self.nodes_goal_tree
        kdtree = self.kdtree_start if tree_type == 'start' else self.kdtree_goal
        if not nodes_list: return None
        if kdtree is None or len(nodes_list) % self.kdtree_rebuild_freq == 0:
            self._build_kdtree(tree_type)
            kdtree = self.kdtree_start if tree_type == 'start' else self.kdtree_goal
        if kdtree is None:
            return min(nodes_list, key=lambda n: math.hypot(n.x - pos_xy[0], n.y - pos_xy[1]), default=None)
        _, indices = kdtree.query(pos_xy)
        idx = indices[0] if isinstance(indices, (np.ndarray, list)) else indices
        idx = int(idx)
        if 0 <= idx < len(nodes_list): return nodes_list[idx]
        return None

    def _get_global_target_sample(self, current_tree_type):
        rand_x = random.uniform(0, self.grid_dims[1] - 1) # width
        rand_y = random.uniform(0, self.grid_dims[0] - 1) # height
        return (rand_x, rand_y)

    def _sample_position_randomly(self, iteration_index, overall_target_pos_xy):
        # This function is the user's original, now primarily for visualization data.
        # It uses self.last_start_node/last_goal_node as center.
        # Its output (x,y) is NOT directly used for _extend_tree's main target anymore.
        is_start_tree_turn = (iteration_index % 2 == 0)
        center_node = self.last_start_node if is_start_tree_turn else self.last_goal_node
        cx, cy, theta0 = center_node.x, center_node.y, center_node.theta

        self.recorded_centers.append((cx, cy, theta0))

        rels_ordered = [0.0, math.pi / 4, -math.pi / 4]
        candidate_local_points_viz = []
        for rel_angle in rels_ordered:
            target_theta = normalize_angle(theta0 + rel_angle)
            # Use self.local_viz_step_size for the cone visualization steps
            cand_x = cx + self.local_viz_step_size * math.cos(target_theta)
            cand_y = cy + self.local_viz_step_size * math.sin(target_theta)
            cand_x = min(max(cand_x, 0), self.grid_dims[1] - 1)
            cand_y = min(max(cand_y, 0), self.grid_dims[0] - 1)
            if not fast_collision_check(cand_y, cand_x, self.collision_lookup):
                candidate_local_points_viz.append({'point': (cand_x, cand_y, target_theta), 'rel_angle': rel_angle})
        if candidate_local_points_viz:
            best_candidate_viz = None; highest_score_viz = -float('inf')
            for cand_info in candidate_local_points_viz:
                (px, py, p_theta), rel_angle_orig = cand_info['point'], cand_info['rel_angle']
                dist_to_overall_target = math.hypot(px - overall_target_pos_xy[0], py - overall_target_pos_xy[1])
                score_prox = 1.0 / (1.0 + dist_to_overall_target)
                score_straight = 1.0 if rel_angle_orig == 0.0 else 0.5
                vec_cand_x, vec_cand_y = px - cx, py - cy; norm_cand = math.hypot(vec_cand_x, vec_cand_y)
                vec_overall_x, vec_overall_y = overall_target_pos_xy[0]-cx, overall_target_pos_xy[1]-cy; norm_overall = math.hypot(vec_overall_x, vec_overall_y)
                score_dir = 0.0
                if norm_cand > 1e-6 and norm_overall > 1e-6:
                    score_dir = (vec_cand_x*vec_overall_x + vec_cand_y*vec_overall_y) / (norm_cand*norm_overall)
                    score_dir = (score_dir + 1) / 2
                total_score = (0.2*score_prox) + (0.4*score_straight) + (0.4*score_dir)
                if total_score > highest_score_viz: highest_score_viz=total_score; best_candidate_viz=cand_info['point']
            
            if not best_candidate_viz and candidate_local_points_viz: # Fallback if scoring somehow fails
                 best_candidate_viz = candidate_local_points_viz[0]['point']
            
            if best_candidate_viz:
                final_x, final_y, final_theta = best_candidate_viz
                self.recorded_samples_local_viz.append((final_x, final_y)) # Use separate list for these
                # Update last_..._node for visualization continuity
                temp_viz_node = RRTNode(final_x, final_y, final_theta, parent=center_node, cost=center_node.cost + self.local_viz_step_size)
                if is_start_tree_turn: self.last_start_node = temp_viz_node
                else: self.last_goal_node = temp_viz_node
                return # This function now primarily updates viz data

        # Fallback jitter for visualization if no local preferred direction is free
        jx = min(max(cx + random.uniform(-self.local_viz_step_size, self.local_viz_step_size), 0), self.grid_dims[1]-1)
        jy = min(max(cy + random.uniform(-self.local_viz_step_size, self.local_viz_step_size), 0), self.grid_dims[0]-1)
        self.recorded_samples_local_viz.append((jx, jy))
        # No RRTNode update for jitter for simplicity, might cause small viz jump if jitter is frequent.
        return


    def _generate_node_kinodynamic(self, from_node, target_pos_xy, target_theta_opt=None, tree_type='start',
                                   is_connection_attempt=False, force_heading_for_local_exploration=False):
        target_state_for_scoring = (target_pos_xy[0], target_pos_xy[1], target_theta_opt)
        best_score, best_end_node_from_primitive = float('inf'), None
        use_heading_cost_primitive = (target_theta_opt is not None) and (is_connection_attempt or force_heading_for_local_exploration)

        for primitive_model in self.primitives:
            if not primitive_model: continue
            transformed_path = self._transform_primitive(primitive_model, from_node)
            if not transformed_path or len(transformed_path) < 2: continue
            end_state = transformed_path[-1]
            if math.hypot(end_state[0]-from_node.x, end_state[1]-from_node.y) < 0.01 : continue
            dist_xy_cost = math.hypot(end_state[0] - target_state_for_scoring[0], end_state[1] - target_state_for_scoring[1])
            score = dist_xy_cost + abs(primitive_model[0][4]) * self.smoothness_weight
            if use_heading_cost_primitive:
                angle_diff = abs(normalize_angle(end_state[2] - target_state_for_scoring[2]))
                score += angle_diff * self.goal_heading_weight
            if score < best_score:
                collision_free = True
                for point_state in transformed_path[1:]:
                    if fast_collision_check(point_state[1], point_state[0], self.collision_lookup):
                        collision_free = False; break
                if collision_free:
                    best_score = score
                    seg_cost = (len(primitive_model)-1) * self.dt
                    best_end_node_from_primitive = RRTNode(*end_state, cost=from_node.cost + seg_cost, parent=from_node)
                    best_end_node_from_primitive.path_from_parent = transformed_path
        if best_end_node_from_primitive: return best_end_node_from_primitive
        return self._apply_controls(from_node, target_state_for_scoring, is_connection_attempt)

    def _apply_controls(self, from_node, target_state, is_connection_attempt=False):
        x_c, y_c, th_c, v_c, phi_c = from_node.get_state()
        t_x, t_y, t_th_opt = target_state
        dx, dy = t_x - x_c, t_y - y_c
        dist_xy = math.hypot(dx, dy)
        if dist_xy < 0.1: return None
        path_seg = [from_node.get_state()]
        # Use local_viz_step_size (original self.step_size) for PFF scaling and num_steps
        # This makes PFF generate segments of comparable length to one local viz step
        vel_scale = min(1.0, dist_xy / (2.0 * self.local_viz_step_size))
        vel = self.max_velocity * vel_scale
        align = max(0.1, math.cos(normalize_angle(math.atan2(dy,dx) - th_c)))
        vel = max(self.min_velocity, vel * align); vel = min(vel, self.max_velocity)
        head_err = normalize_angle(math.atan2(dy, dx) - th_c)
        steer = max(-self.max_steering_angle*0.9, min(self.steering_gain * head_err, self.max_steering_angle*0.9))
        num_steps = max(5, min(int(min(dist_xy, self.local_viz_step_size) / (vel * self.dt + 1e-6)), 25))

        tmp_x, tmp_y, tmp_th = x_c,y_c,th_c
        for _ in range(num_steps):
            nx = tmp_x + vel * math.cos(tmp_th) * self.dt
            ny = tmp_y + vel * math.sin(tmp_th) * self.dt
            nth = normalize_angle(tmp_th + (vel * math.tan(steer) / self.vehicle_length) * self.dt)
            if fast_collision_check(ny, nx, self.collision_lookup): return None
            tmp_x,tmp_y,tmp_th = nx,ny,nth
            path_seg.append((tmp_x,tmp_y,tmp_th,vel,steer))
        if len(path_seg)<=1: return None
        final_s = path_seg[-1]
        new_node = RRTNode(*final_s, cost=from_node.cost + (len(path_seg)-1)*self.dt, parent=from_node)
        new_node.path_from_parent = path_seg
        return new_node

    def _extend_tree(self, tree_nodes, tree_type, global_target_xy):
        nearest_node = self._get_nearest_node(global_target_xy, tree_type)
        if not nearest_node: return None

        target_theta_for_expansion = None
        is_direct_goal_attempt = False
        if global_target_xy == (self.true_goal_node_spec.x, self.true_goal_node_spec.y) and tree_type == 'start':
            target_theta_for_expansion = self.true_goal_node_spec.theta
            is_direct_goal_attempt = True
        elif global_target_xy == (self.start_node.x, self.start_node.y) and tree_type == 'goal':
            target_theta_for_expansion = self.start_node.theta # True world theta for start
            is_direct_goal_attempt = True

        new_node = self._generate_node_kinodynamic(nearest_node, global_target_xy,
                                                   target_theta_opt=target_theta_for_expansion, tree_type=tree_type,
                                                   is_connection_attempt=is_direct_goal_attempt,
                                                   force_heading_for_local_exploration=False)
        if new_node:
            tree_nodes.append(new_node)
            return new_node
        return None

    def _try_connect_trees(self, new_node_a, tree_a_type):
        other_type = 'goal' if tree_a_type == 'start' else 'start'
        # print("Other type", other_type)
        near_other = self._get_nearest_node((new_node_a.x, new_node_a.y), other_type)
        if not near_other: return False
        dist = math.hypot(new_node_a.x - near_other.x, new_node_a.y - near_other.y)
        if dist > self.connect_max_dist_factor * self.nominal_connect_attempt_distance : return False
        t_x, t_y = near_other.x, near_other.y
        t_th = self._inverse_angle(near_other.theta) if other_type == 'goal' else near_other.theta
        a_x, a_y = new_node_a.x, new_node_a.y
        a_th = self._inverse_angle(new_node_a.theta) if other_type == 'start' else new_node_a.theta
        conn_node = self._generate_node_kinodynamic(new_node_a, (t_x, t_y), t_th, tree_a_type, True, False)
        if conn_node:
            conn_node.theta = self._inverse_angle(conn_node.theta if other_type == 'start' else conn_node.theta)
            # print(f"new_node_a: {a_x, a_y, a_th}, conn_node: {conn_node.get_state()}")
            # print(f"near_other: {t_x, t_y, t_th}")
            pos_ok = math.hypot(conn_node.x-t_x, conn_node.y-t_y) <= self.goal_position_threshold
            ang_ok = abs(normalize_angle(conn_node.theta - t_th)) <= self.goal_angle_threshold
            ang_ok_second = abs(normalize_angle(conn_node.theta - a_th)) <= self.goal_angle_threshold
            # print("checked angle: ", abs(normalize_angle(conn_node.theta - t_th)), conn_node.theta - t_th)
            # print("checked angle second: ", abs(normalize_angle(conn_node.theta - a_th)), conn_node.theta - a_th)
            # print("checked with angle:", self.goal_angle_threshold)
            # ang_ok = abs(normalize_angle((conn_node.theta - t_th)*180 <= self.goal_angle_threshold))
            if pos_ok and ang_ok and ang_ok_second:
                self.connection_details = (conn_node, near_other) if tree_a_type == 'start' else (near_other, conn_node)
                self.path_found = True; return True
        return False

    def plan(self, visualize_final=True):
        print("Starting optimized kinodynamic RRT planning...")
        self.start_time = time.time()
        self.recorded_samples = [] # Clear for this planning run
        self.recorded_samples_local_viz = [] # Clear for this planning run
        self.recorded_centers = [] # Clear for this planning run

        for i in range(self.max_iter):
            if time.time() - self.start_time > self.time_budget: print("Time budget exceeded."); break
            if (i+1)%200==0: print(f"Iter {i+1}, Start Tree: {len(self.nodes_start_tree)}, Goal Tree: {len(self.nodes_goal_tree)}")

            is_start_tree_turn = len(self.nodes_start_tree) <= len(self.nodes_goal_tree) # Prioritize smaller tree
            if abs(len(self.nodes_start_tree) - len(self.nodes_goal_tree)) <= 5 : # If balanced, alternate
                 is_start_tree_turn = (i % 2 == 0)
            
            current_nodes, current_type = (self.nodes_start_tree, 'start') if is_start_tree_turn else (self.nodes_goal_tree, 'goal')
            overall_target_for_bias = (self.true_goal_node_spec.x, self.true_goal_node_spec.y) if current_type == 'start' \
                                 else (self.start_node.x, self.start_node.y)

            # Get the main global target for _extend_tree
            global_target_xy_for_extension = self._get_global_target_sample(current_type)
            self.recorded_samples.append(global_target_xy_for_extension) # Record global sample

            # Run the user's original sampling logic primarily for visualization updates
            # It will use self.last_..._node and bias its choice towards global_target_xy_for_extension
            self._sample_position_randomly(i, global_target_xy_for_extension) # This updates viz lists and last_..._nodes
            if i < 10:
                print(f"Sampled local viz point: {self.recorded_samples_local_viz[-1]} from center {self.recorded_centers[-1]}")
                print(f"Sampled global point: {global_target_xy_for_extension} from center {self.recorded_centers[-1]}")
            # Extend the tree using the global target
            added_node = self._extend_tree(current_nodes, current_type, global_target_xy_for_extension)
            
            if added_node:
                if self._try_connect_trees(added_node, current_type):
                    print(f"Path found and connected at iteration {i+1}!"); break
        
        if not self.path_found: print(f"Final global samples: {len(self.recorded_samples)}, local viz samples: {len(self.recorded_samples_local_viz)}")
        if self.path_found:
            final_path = self._extract_path()
            if visualize_final: self._visualize_bidirectional_result(final_path)
            return final_path
        else:
            print("No path found within iterations/time.")
            if visualize_final: self._visualize_bidirectional_result(None)
            return None

    def _extract_path(self): # Same as before
        if not self.path_found or not self.connection_details: return None
        node_s, node_g = self.connection_details
        path_s_to_conn = []
        curr = node_s
        while curr:
            if curr.path_from_parent: path_s_to_conn = [(p[0],p[1],p[2]) for p in curr.path_from_parent] + path_s_to_conn
            elif curr == self.start_node: path_s_to_conn.insert(0, (curr.x, curr.y, curr.theta))
            curr = curr.parent
        def deduplicate_path_tuples(path_tuples):
            if not path_tuples: return []
            deduped = [path_tuples[0]]
            for i in range(1, len(path_tuples)):
                p1,p2 = deduped[-1],path_tuples[i]
                if not(abs(p1[0]-p2[0])<1e-3 and abs(p1[1]-p2[1])<1e-3 and abs(normalize_angle(p1[2]-p2[2]))<1e-3):
                    deduped.append(p2)
            return deduped
        path_s_to_conn = deduplicate_path_tuples(path_s_to_conn)
        path_g_to_conn_rev = []
        curr = node_g
        while curr:
            if curr.path_from_parent: path_g_to_conn_rev = [(p[0],p[1],self._inverse_angle(p[2])) for p in curr.path_from_parent] + path_g_to_conn_rev
            elif curr == self.goal_node_for_tree: path_g_to_conn_rev.insert(0, (curr.x, curr.y, self._inverse_angle(curr.theta)))
            curr = curr.parent
        path_g_to_conn_rev = deduplicate_path_tuples(path_g_to_conn_rev)
        path_conn_to_g = list(reversed(path_g_to_conn_rev))
        final_path_tuples = path_s_to_conn
        if path_s_to_conn and path_conn_to_g:
            if abs(final_path_tuples[-1][0]-path_conn_to_g[0][0])<0.1 and \
               abs(final_path_tuples[-1][1]-path_conn_to_g[0][1])<0.1 and \
               abs(normalize_angle(final_path_tuples[-1][2]-path_conn_to_g[0][2]))<math.radians(5):
                final_path_tuples.extend(path_conn_to_g[1:])
            else: final_path_tuples.extend(path_conn_to_g)
        elif path_conn_to_g: final_path_tuples.extend(path_conn_to_g)
        return final_path_tuples

    def _transform_primitive(self, primitive_relative_path, from_node): # Same as user's
        if not primitive_relative_path: return []
        transformed_path_segment = []
        base_x, base_y, base_theta = from_node.x, from_node.y, from_node.theta
        for i, (rel_x, rel_y, rel_theta, p_v, p_phi) in enumerate(primitive_relative_path):
            rotated_x = rel_x * math.cos(base_theta) - rel_y * math.sin(base_theta)
            rotated_y = rel_x * math.sin(base_theta) + rel_y * math.cos(base_theta)
            global_x = rotated_x + base_x; global_y = rotated_y + base_y
            global_theta = normalize_angle(rel_theta + base_theta)
            transformed_path_segment.append((global_x, global_y, global_theta, p_v, p_phi))
        return transformed_path_segment

    def _visualize_bidirectional_result(self, path_tuples): # Same as user's
        plt.figure(figsize=(13, 13))
        plt.imshow(self.collision_lookup["collision_mask"], origin='lower', cmap='Greys', extent=[0, self.grid_dims[1], 0, self.grid_dims[0]])
        for node_list, color_str in [(self.nodes_start_tree, 'deepskyblue'), (self.nodes_goal_tree, 'lightcoral')]:
            for node in node_list:
                if node.parent and node.path_from_parent and len(node.path_from_parent) > 0:
                    xs = [p[0] for p in node.path_from_parent]; ys = [p[1] for p in node.path_from_parent]
                    plt.plot(xs, ys, color=color_str, alpha=0.5, linewidth=1.5)
        plt.scatter(self.start_node.x, self.start_node.y, color='lime', s=120, marker='o', edgecolor='black', label='Start', zorder=5)
        plt.arrow(self.start_node.x, self.start_node.y, 2.0*math.cos(self.start_node.theta), 2.0*math.sin(self.start_node.theta), color='lime', head_width=0.7, head_length=0.9, edgecolor='black', linewidth=1.5, zorder=5)
        plt.scatter(self.true_goal_node_spec.x, self.true_goal_node_spec.y, color='red', s=120, marker='X', edgecolor='black', label='Goal', zorder=5)
        plt.arrow(self.true_goal_node_spec.x, self.true_goal_node_spec.y, 2.0*math.cos(self.true_goal_node_spec.theta), 2.0*math.sin(self.true_goal_node_spec.theta), color='red', head_width=0.7, head_length=0.9, edgecolor='black', linewidth=1.5, zorder=5)
        if self.connection_details:
            node_s, node_g = self.connection_details
            plt.scatter(node_s.x, node_s.y, color='gold', s=150, marker='*', edgecolor='black', label='Connection Pt (Start Tree Side)', zorder=6)
            plt.scatter(node_g.x, node_g.y, color='orange', s=150, marker='*', edgecolor='black', label='Connection Pt (Goal Tree Side)', zorder=6)
        if path_tuples and len(path_tuples) > 1:
            xs = [p[0] for p in path_tuples]; ys = [p[1] for p in path_tuples]
            plt.plot(xs, ys, color='green', linestyle='-', linewidth=2.0, label='Final Path', zorder=4)
            for i in range(0, len(path_tuples), max(1, len(path_tuples)//25)):
                plt.arrow(path_tuples[i][0], path_tuples[i][1], 1.2*math.cos(path_tuples[i][2]), 1.2*math.sin(path_tuples[i][2]), color='darkgreen', head_width=0.3, head_length=0.5, alpha=0.8, zorder=4)
        plt.title("Bidirectional Kinodynamic RRT Path Planning"); plt.xlabel("X-position (m)"); plt.ylabel("Y-position (m)")
        plt.legend(fontsize='small'); plt.axis('equal'); plt.grid(True, linestyle=':', alpha=0.6); plt.tight_layout(); 
        #save image below
        # plt.show()
        plt.savefig(f"bidirectional_kinodynamic_rrt_path{time.time()}.png", dpi=300)
        # plt.show()
   
    def visualize_sampling(self):
        if not self.recorded_samples and not self.recorded_samples_local_viz:
            print("No samples recorded."); return
        fig, ax = plt.subplots(figsize=(8,8))
        ax.imshow(self.collision_lookup["collision_mask"], origin='lower', cmap='gray', extent=[0, self.grid_dims[1], 0, self.grid_dims[0]])
        ax.set_aspect('equal'); ax.set_title("Sampling Visualization")
        
        if self.recorded_centers: # From _sample_position_randomly (local viz)
             centers_x = [c[0] for c in self.recorded_centers]; centers_y = [c[1] for c in self.recorded_centers]
             ax.scatter(centers_x, centers_y, c='blue', s=15, label="Local Viz Centers (last_node)", alpha=0.3)
        if self.recorded_samples_local_viz: # From _sample_position_randomly
            xs_local, ys_local = zip(*self.recorded_samples_local_viz)
            ax.scatter(xs_local, ys_local, c='cyan', s=20, label="Local Viz Choices", alpha=0.6, marker='x')
        if self.recorded_samples: # Global samples for _extend_tree
            xs_global, ys_global = zip(*self.recorded_samples)
            ax.scatter(xs_global, ys_global, c='tab:orange', s=20, label="Global Targets for Extend", alpha=0.7)
        ax.legend(); 
        plt.savefig(f"sampling_visualization{time.time()}.png", dpi=300)
        # plt.show()
        # plt.show()

    def animate_sampling(self, num_frames=200, interval=100):
        if not self.recorded_centers or not self.recorded_samples_local_viz: print("Not enough data for animation."); return
        fig, ax = plt.subplots(figsize=(8,8))
        ax.imshow(self.collision_lookup["collision_mask"], origin='lower', cmap='gray', extent=[0, self.grid_dims[1], 0, self.grid_dims[0]])
        ax.set_aspect('equal'); ax.set_title("Local Cone-Sampling Animation")
        scat = ax.scatter([], [], c='tab:orange', s=30) # Will show recorded_samples_local_viz
        all_rays = [ax.plot([], [], color='gray', linestyle='--', linewidth=1)[0] for _ in range(self.num_arcs)]
        highlight_ray, = ax.plot([], [], color='red', linewidth=2)
        def init_anim():
            scat.set_offsets(np.empty((0,2)));
            for r_line in all_rays: r_line.set_data([],[])
            highlight_ray.set_data([],[]); return [scat, highlight_ray] + all_rays
        
        actual_frames = min(len(self.recorded_centers), len(self.recorded_samples_local_viz), num_frames)
        if actual_frames == 0: print("Cannot animate, no frames."); return None

        def update_anim(frame):
            cx, cy, theta0 = self.recorded_centers[frame]
            if self.num_arcs > 1: rels_an = [-self.half_cone + j*(2*self.half_cone)/(self.num_arcs-1) for j in range(self.num_arcs)]
            else: rels_an = [0.0] if self.num_arcs == 1 else []
            for j, r_line in enumerate(all_rays):
                if j < len(rels_an):
                    ang = normalize_angle(theta0+rels_an[j]); x0,y0=cx+self.min_radius*math.cos(ang),cy+self.min_radius*math.sin(ang)
                    x1,y1=cx+self.max_radius*math.cos(ang),cy+self.max_radius*math.sin(ang); r_line.set_data([x0,x1],[y0,y1])
                else: r_line.set_data([],[])
            idx_an = frame % self.num_arcs
            if idx_an < len(rels_an):
                angh=normalize_angle(theta0+rels_an[idx_an]); hx0,hy0=cx+self.min_radius*math.cos(angh),cy+self.min_radius*math.sin(angh)
                hx1,hy1=cx+self.max_radius*math.cos(angh),cy+self.max_radius*math.sin(angh); highlight_ray.set_data([hx0,hx1],[hy0,hy1])
            else: highlight_ray.set_data([],[])
            # Animate using recorded_samples_local_viz
            pts = np.array(self.recorded_samples_local_viz[:frame+1])
            if pts.size > 0 : scat.set_offsets(pts)
            else: scat.set_offsets(np.empty((0,2)))
            return [scat, highlight_ray] + all_rays
        anim_obj = animation.FuncAnimation(fig,update_anim,frames=actual_frames,init_func=init_anim,blit=True,interval=interval)
        plt.savefig(f"sampling_animation{time.time()}.png", dpi=300)
        # plt.show(); 
        return anim_obj